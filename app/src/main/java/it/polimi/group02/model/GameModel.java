package it.polimi.group02.model;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import it.polimi.group02.model.utility.Color;
import it.polimi.group02.model.validator.AnyMoveValidator;
import it.polimi.group02.model.validator.DiagonalAttackValidator;
import it.polimi.group02.model.validator.FreezeValidator;
import it.polimi.group02.model.validator.HealValidator;
import it.polimi.group02.model.validator.HorizontalVerticalAttackValidator;
import it.polimi.group02.model.validator.HorizontalVerticalMoveValidator;
import it.polimi.group02.model.utility.Direction;
import it.polimi.group02.model.utility.Status;
import it.polimi.group02.model.validator.ReviveValidator;
import it.polimi.group02.model.validator.TeleportValidator;

import static it.polimi.group02.model.utility.Color.BLACK;
import static it.polimi.group02.model.utility.Color.WHITE;
import static it.polimi.group02.model.utility.Direction.ANY;
import static it.polimi.group02.model.utility.Direction.DIAGONAL;
import static it.polimi.group02.model.utility.Direction.HORIZONTAL_VERTICAL;
import static it.polimi.group02.model.utility.Direction.NOT_AVAILABLE;
import static it.polimi.group02.model.utility.Status.FROZEN;
import static it.polimi.group02.model.utility.Utility.*;
import static java.lang.Character.isLowerCase;
import static java.lang.Character.isUpperCase;


/**
 *
 */
public class GameModel {
    /**
     * An array containing the players of each game; in this game, two players are playing.
     */
    private Player[] players;
    /**
     * A matrix of characters storing the current status of the fantasy_board. The convention used is the following:
     * - an empty cell corresponds to a "0" character
     * - every piece corresponds to its first letter, white pieces are in upper case, black pieces in lower case, eg:
     *      white Giant is "G", black giant is "g"
     *      white Dragon in "D", black dragon in "d"
     */
    private char[][] currentConfiguration;
    /**
     * This matrix stores the initial state of the game, which corresponds to the default initial configuration.
     */
    private char[][] initialConfiguration;
    /**
     * This attribute represents the turn to classic_play.
     */
    private int turn;
    /**
     * This array holds as many list of pieces as many players, so each list contains the pieces of its corresponding player.
     * When a piece is killed, it is removed from the list.
     */
    private List<Piece>[] pieces;
    /**
     * This attribute holds the number of killed pieces.
     */
    private int numberOfDeadPieces;
    /**
     * This string holds the message generated by the outcome of an action; it has length > 0 either if it is set to an error message as
     * consequence from an invalid action, or if the game has ended.
     */
    private String finalMessage;
    /**
     * This attribute is useful to stop the tests once you reach the end of the game; it will be useful for the final release of the game too.
     */
    private boolean gameOver;

    /**
     * The following attributes are useful to collect some statistics about the game.
     */
    /**
     * This array contains the scores for each player.
     */
    private int[] scores;
    /**
     * This string contains the color of the winner of the game.
     */
    private String winner;
    /**
     * This attribute stores the formatted string with the date on which this instance of game is created.
     */
    private String dateFormat;
    /**
     * This attribute stores the number of pieces left at the end of the game.
     */
    private int numberOfPiecesLeft;
    /**
     * This attribute stores the number of turns played.
     */
    private int numberOfTurns;
    /**
     * This attribute is set to true id three special cells are occupied by the winner of this game, false otherwise.
     */
    private boolean occupiedThreeSpecialCells;



    /**
     * Constructor.
     */
    public GameModel() {
        players = new Player[NUMBER_OF_PLAYERS];
        pieces = new List[NUMBER_OF_PLAYERS];
        currentConfiguration = new char[BOARD_SIDE_SIZE][BOARD_SIDE_SIZE];
        initialConfiguration = new char[BOARD_SIDE_SIZE][BOARD_SIDE_SIZE];
        numberOfDeadPieces = 0;
        finalMessage = "";
        gameOver = false;

        scores = new int[NUMBER_OF_PLAYERS];
        winner = "";
        numberOfPiecesLeft = 0;
        numberOfTurns = 0;
        occupiedThreeSpecialCells = false;

        turn = 0;

        pieces[turn] = new ArrayList<>();
        pieces[turn + 1] = new ArrayList<>();

        // set initial scores
        scores[turn] = 0;
        scores[turn + 1] = 0;

        // set date of game creation
        Date date = new Date();
        dateFormat = new SimpleDateFormat("dd/MM/yy HH:mm", Locale.ITALY).format(date);
    }




    /**
     * This method is used to parse the standard configuration string into a matrix that represents
     * with a symbol how the fantasy_board is initially configured and occupied by the pieces
     */
    public void createStandardConfigurationMatrix(){
        for (int i = 0; i < BOARD_SIDE_SIZE; i++){
            for(int j = 0; j < BOARD_SIDE_SIZE; j++){
                //the method charAt takes the char in the string at position i+j
                this.currentConfiguration[i][j] = STANDARD_GAME_CONFIGURATION.charAt( (i*BOARD_SIDE_SIZE) + j );
                initialConfiguration[i][j] = STANDARD_GAME_CONFIGURATION.charAt( (i*BOARD_SIDE_SIZE) + j );
            }
        }
    }


    /**
     * This method initializes each player in a game.
     * @param name name of the player
     * @param turn turn of the player
     * @param color color of the player in this match
     */
    public void initializePlayer(String name, int turn, Color color) {
        players[turn] = new Player(name);
        players[turn].setColor(color);
    }


    /**
     * Use factory method design pattern to delegate the instantiation of the subclasses of Piece objects to a factory class,
     * which handles all the possible cases applying the principle of encapsulation; this avoids to put in the model the selection of
     * the instances, making it clearer and making the creation of the objects more transparent.
     */
    public void createPieces() {
        char actualValue;
        for (int i = 0; i < BOARD_SIDE_SIZE; i++) {
            for (int j = 0; j < BOARD_SIDE_SIZE; j++) {
                //reverse scrolling of the matrix, column by column, from top to bottom
                actualValue = this.currentConfiguration[j][i];
                if (actualValue != '0') {
                    if (players[turn].getColor() == WHITE) {
                        if (isUpperCase(actualValue)) {//if upper case we are dealing with the first player
                            pieces[turn].add(PieceFactory.createPiece(actualValue, j, i));
                        } else {//if lower case we are dealing with the first player
                            pieces[(turn + 1) % NUMBER_OF_PLAYERS].add(PieceFactory.createPiece(actualValue, j, i));
                        }
                    }
                    else {
                        if (isLowerCase(actualValue)) {
                            pieces[turn].add(PieceFactory.createPiece(actualValue, j, i));
                        } else {
                            pieces[(turn + 1) % NUMBER_OF_PLAYERS].add(PieceFactory.createPiece(actualValue, j, i));
                        }
                    }
                }
            }
        }
    }


    /**
     * This method implements a game turn. First, a player performs an action; after the model has evaluated the validity of this action,
     * it performs a check to evaluate if the game has reached its final state. Finally, at the end of this turn, it switches to next
     * player's turn.
     * @param action a string formatting the action to be taken
     * @return the content of finalMessage attribute which, if of length different from 0, either contains an error or the end of the game
     */
    public String playTurn(String action) {
        // if an invalid action has been done, don't check the end of the game nor start the next turn
        if (!parseAction(action).startsWith("ERROR")) {
            checkEndOfGame();
            repriseTurn();
            numberOfTurns++;
        }

        return finalMessage;
    }


    /**
     * This method performs a check of an action, and based on the type of action (move, attack, spell) it calls the related validators
     * to validate the correctness of the given action. If the result is positive, it is allowed to perform the given action; otherwise,
     * an error message is generated.
     * @param action a string of the following format:
     *               -  the first character can be "M" (move), "A" (attack), "H" (heal), "T" (teleport), "R"(revive), or "F" (freeze)
     *               -  the next two characters represent the source cell position, i.e., where the piece that moves or attacks or
     *                  receives a spell is at
     *               -  the next two characters represent the destination cell position, i.e., where the piece moves to or sends its
     *                  attack to or is teleported to. If the destination cell does not make sense (as in "H", "R", "F"), these two
     *                  characters are "00"
     */
    public String parseAction(String action) {
        finalMessage = "";

        char command = action.charAt(0);
        // remember prof cell coordinate is (col, row)
        int ySource = (new Integer(action.substring(1, 2)).intValue() - 1);
        int xSource = (new Integer(action.substring(2, 3)).intValue() - 1);
        int yTarget = new Integer(action.substring(3, 4)).intValue();
        int xTarget = new Integer(action.substring(4, 5)).intValue();

        //check if either source and target position is out of the fantasy_board; this condition doesn't check whether the target x or y are equals 0.
        if (xSource >= BOARD_SIDE_SIZE || ySource >= BOARD_SIDE_SIZE || xTarget > BOARD_SIDE_SIZE || yTarget > BOARD_SIDE_SIZE ||
                xSource < 0 || ySource < 0 || xTarget < 0 || yTarget < 0) {
            return generateError("ERROR: the final position is out of the fantasy_board");
        }
        // for M, A, T: target (x,y) must be != 0; for F, H, R: target (x,y) must be == 0
        if ((command == 'M' || command == 'A'|| command == 'T') && (xTarget == 0 || yTarget == 0) || (command == 'F'||
                command == 'H' || command == 'R') && (xTarget != 0 || yTarget != 0)) {
            return generateError("ERROR: invalid action");
        }

        // now can decrement target (x,y) to allow correct location for M, A, T; as for F, H or R, it's not considered at all
        xTarget -= 1;
        yTarget -= 1;

        boolean flag = false;

        // check if in position (ySource, xSource) there's a piece belonging to the player playing the current turn
        Piece selectedPiece;
        if(command=='F'){
            selectedPiece = getPieceAtTurn((turn+1)%NUMBER_OF_PLAYERS, ySource, xSource);
        }else{
            selectedPiece = getPieceAtTurn(turn, ySource, xSource);
        }
        if (command!='R' && selectedPiece == null) {
            flag = true;
        }

        /* if the source position is wrong, that is either it's an invalid position ('0') or the position of the piece of
            the opponent playing the turn
          */
        if (flag) {
            return generateError("ERROR: the starting player isn't correct");
        }

        Direction movingDirection;
        Direction attackingDirection;
        Player playerPlaying;

        // these if-else separates the possible types of command
        if (command == 'M') {
            if(selectedPiece.getStatus()==Status.ACTIVE) {
                movingDirection = selectedPiece.getMoveDirection();
                if (movingDirection == HORIZONTAL_VERTICAL) {
                    //case HORIZONTAL_VERTICAL:
                    HorizontalVerticalMoveValidator hrValidator = new HorizontalVerticalMoveValidator(currentConfiguration, selectedPiece, xSource, ySource, xTarget, yTarget);
                    if (hrValidator.checkMove()) {
                        performMove(yTarget, xTarget, selectedPiece, hrValidator);
                    } else {
                        return generateError("ERROR: it's not possible to make a move");
                    }
                    //case ANY:
                } else if (movingDirection == ANY) {
                    AnyMoveValidator anyValidator = new AnyMoveValidator(currentConfiguration, selectedPiece, xSource, ySource, xTarget, yTarget);
                    if (anyValidator.checkMove()) {
                        performMove(yTarget, xTarget, selectedPiece, anyValidator);
                    } else {
                        return generateError("ERROR: it's not possible to make a move");
                    }
                }
            }else{
                return generateError("ERROR: This piece cannot be moved because frozen");
            }
        } else if (command == 'A') {
            if (selectedPiece.getStatus() == Status.ACTIVE) {
                attackingDirection = selectedPiece.getAttackDirection();

                if (attackingDirection == HORIZONTAL_VERTICAL) {
                    HorizontalVerticalAttackValidator hvav = new HorizontalVerticalAttackValidator(currentConfiguration, selectedPiece, xSource, ySource, xTarget, yTarget);
                    if (hvav.checkAttack()) {
                        performAttack(xTarget, yTarget, selectedPiece);
                    } else {
                        return generateError(hvav.getErrorMessage());
                    }
                } else if (attackingDirection == DIAGONAL) {
                    DiagonalAttackValidator dav = new DiagonalAttackValidator(currentConfiguration, selectedPiece, xSource, ySource, xTarget, yTarget);
                    if (dav.checkAttack()) {
                        performAttack(xTarget, yTarget, selectedPiece);
                    } else {
                        return generateError(dav.getErrorMessage());
                    }
                }
                else if (attackingDirection == NOT_AVAILABLE) {
                    return generateError("ERROR: neither mage nor squire can attack");
                }
            }
            else{
                return generateError("ERROR: The selected piece cannot attack because it's frozen");
            }
        }
        // Commands regarding to casting spells
        else if (command == 'H') {
            if(playerHasMage(turn)) {
                playerPlaying = players[this.turn];
                HealValidator hvv = new HealValidator(getCurrentConfiguration(),selectedPiece,xSource,ySource,playerPlaying);
                if (hvv.checkSpell()){
                    castHeal(selectedPiece, playerPlaying);
                }else{
                    return generateError(hvv.getErrorMessage());
                }
            }else {
                return generateError("ERROR: This player cannot cast spells");
            }

        } else if (command == 'T') {
            if (playerHasMage(turn)) {
                playerPlaying = players[this.turn];
                TeleportValidator tv = new TeleportValidator(this.getCurrentConfiguration(),selectedPiece,xSource,ySource,xTarget,yTarget,playerPlaying);
                if(tv.checkSpell()){
                    castTeleport(xSource, ySource, xTarget, yTarget, selectedPiece, playerPlaying);
                }
                else{
                    return generateError(tv.getErrorMessage());
                }
            } else {
                return generateError("ERROR: This player cannot cast spells");
            }

        } else if (command == 'R') {
            if (playerHasMage(turn)) {
                playerPlaying = players[this.turn];
                ReviveValidator rv = new ReviveValidator(this.getCurrentConfiguration(),selectedPiece,xSource,ySource,playerPlaying,initialConfiguration,turn);
                if(rv.checkSpell()){
                    castRevive(rv.getSymbolToRevive(), xSource, ySource, playerPlaying);
                }else{
                    return generateError(rv.getErrorMessage());
                }

            }else {
                return generateError("ERROR: This player cannot cast spells");
            }

        }else if (command == 'F') {
            if (playerHasMage(turn)){
                Player opponentPlayer = players[(turn+1)%NUMBER_OF_PLAYERS];
                playerPlaying = players[turn];
                FreezeValidator fv = new FreezeValidator(this.getCurrentConfiguration(),selectedPiece,xSource,ySource,playerPlaying,turn);

                if(fv.checkSpell()){
                    castFreeze(selectedPiece, playerPlaying, opponentPlayer);
                }else{
                    return generateError(fv.getErrorMessage());
                }
            }else{
                return generateError("ERROR: This player cannot cast spells");
            }
        }

        return finalMessage;
    }


    /**
     * This method implements the movement. It calls the updateBoard(int, int, Piece) method to update the position attributes of a Piece
     * object and to update the currentConfiguration matrix, so the game representation is always updated. If in the target cell an enemy
     * is present, it calls the startCombat(int, int, Piece method).
     * @param yTarget column position of target cell
     * @param xTarget row position of target cell
     * @param selectedPiece the piece that performs the move
     * @param hrValidator the move validator
     */
    public void performMove(int yTarget, int xTarget, Piece selectedPiece, HorizontalVerticalMoveValidator hrValidator) {
        Piece foe = null;
        // if in the target cell there's an opponent, start a combat
        if (hrValidator.isStartCombat()) {
            foe = getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, yTarget, xTarget);
            engageInBattle(selectedPiece, foe);
        }else{//if there is not a combat the piece can move in the selected position
            updateBoard(xTarget, yTarget, selectedPiece);
        }
    }


    /**
     * This method implements the attack. The attacking piece decrements its opponent's piece vitality by the amount of its strength.
     * If the opponent's vitality gets to 0, it should be removed from its list.
     * @param xTarget row position of target cell
     * @param yTarget column position of target cell
     * @param selectedPiece the piece that performs the attack
     */
    public void performAttack(int xTarget, int yTarget, Piece selectedPiece) {
        Piece foe = null;
        foe = getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, yTarget, xTarget);
        int foeCurrentVitality = foe.getVitality();
        foe.setVitality(foe.getVitality() - selectedPiece.getAttackStrength().getValue());

        if (foe.getVitality() <= 0) {
            this.currentConfiguration[foe.getxCoordinate()][foe.getyCoordinate()] = '0';
            // assign points to playing player
            scores[turn] += foeCurrentVitality + (1 / selectedPiece.getAttackStrength().getValue()) * MAX_STRENGTH;
            pieces[(turn + 1) % NUMBER_OF_PLAYERS].remove(getPieceIndexAtTurn((turn + 1) % NUMBER_OF_PLAYERS,foe.getyCoordinate(),foe.getxCoordinate()));
            if(foe.getStatus() == FROZEN) {
                if (isUpperCase(foe.getPieceSymbol())) {
                    this.getPlayers()[0].setFrozenPiece(false);
                    this.getPlayers()[0].setFrozenPieceInformation("000");
                } else {
                    this.getPlayers()[1].setFrozenPiece(false);
                    this.getPlayers()[1].setFrozenPieceInformation("000");
                }
            }
            numberOfDeadPieces++;
        }
    }


    /**
     * This method executes the teleport of a piece from its initial cell to the target cell, as long as it complies with the restrictions
     * set by the validator.
     * @param xSource row position of starting cell
     * @param ySource column position of starting cell
     * @param xTarget row position of target cell
     * @param yTarget column position of target cell
     * @param selectedPiece the piece that should be teleported
     * @param player the playing player
     */
    public void castTeleport(int xSource, int ySource, int xTarget, int yTarget, Piece selectedPiece, Player player) {
        int indexOfTeleport = player.getUnusedSpells().indexOf('T');
        // removing the selected piece.
        this.currentConfiguration[xSource][ySource] = '0';
        if (this.getCurrentConfiguration()[xTarget][yTarget] != '0') {
            Piece foe = getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, yTarget, xTarget);
            engageInBattle(selectedPiece, foe);
        }else {
            selectedPiece.setxCoordinate(xTarget);
            selectedPiece.setyCoordinate(yTarget);

            this.currentConfiguration[selectedPiece.getxCoordinate()][selectedPiece.getyCoordinate()] = selectedPiece.getPieceSymbol();
            // if you're teleporting a frozen piece but the target cell isn't occuppied by an enemy
            if (selectedPiece.getStatus() == FROZEN) {
                player.setFrozenPieceInformation(String.valueOf(yTarget + 1) + String.valueOf(xTarget + 1) + String.valueOf(player.getFrozenPieceInformation().charAt(2)));
            }
        }

        player.setUnusedSpells(player.getUnusedSpells().substring(0,indexOfTeleport)+'0'+player.getUnusedSpells().substring(indexOfTeleport+1,player.getUnusedSpells().length()));
    }


    /**
     * This method executes the healing of a piece, restoring its initial vitality, as long as it complies with the restrictions
     * set by the validator.
     * @param selectedPiece the piece that should be healed
     * @param player the playing player
     */
    public void castHeal(Piece selectedPiece, Player player) {
        int indexOfHeal = player.getUnusedSpells().indexOf('H');
        // restoring the initial vitality of the selected pieces
        PieceFactory.setInitialVitality(selectedPiece);

        player.setUnusedSpells(player.getUnusedSpells().substring(0,indexOfHeal)+'0'+player.getUnusedSpells().substring(indexOfHeal+1,player.getUnusedSpells().length()));

    }


    /**
     * This method executes the revival of a dead piece, as long as it complies with the restrictions set by the validator.
     * @param symbolToRevive symbol of the piece
     * @param xTarget row position of target cell
     * @param yTarget column position of target cell
     * @param player the playing player
     */
    public void castRevive(char symbolToRevive, int xTarget, int yTarget, Player player) {
    //  restoring classic_back the killed piece
        int indexOfRevive = player.getUnusedSpells().indexOf('R');
        this.getPieces()[turn].add(PieceFactory.createPiece(symbolToRevive,xTarget,yTarget));
        numberOfDeadPieces--;

        if(turn == 0 && !isUpperCase(this.getCurrentConfiguration()[xTarget][yTarget]) && (this.getCurrentConfiguration()[xTarget][yTarget]!='0') ||
                turn == 1 && isUpperCase(this.getCurrentConfiguration()[xTarget][yTarget]) && this.getCurrentConfiguration()[xTarget][yTarget]!='0'){

            engageInBattle(this.getPieces()[turn].get(this.getPieces()[turn].size()-1),getPieceAtTurn((turn+1)%NUMBER_OF_PLAYERS,yTarget, xTarget));

        }else if(this.getCurrentConfiguration()[xTarget][yTarget] =='0'){
            this.getCurrentConfiguration()[xTarget][yTarget] = symbolToRevive;
        }

        player.setUnusedSpells(player.getUnusedSpells().substring(0,indexOfRevive)+'0'+player.getUnusedSpells().substring(indexOfRevive+1,player.getUnusedSpells().length()));

    }


    /**
     * This method executes the freezing of a piece, as long as it complies with the restrictions set by the validator.
     * @param selectedPiece the piece that should be frozen
     * @param playerPlaying the playing player
     * @param opponentPlayer the opponent player
     */
    // spell for opponent
    public void castFreeze(Piece selectedPiece, Player playerPlaying, Player opponentPlayer) {
        int indexOfFreeze = playerPlaying.getUnusedSpells().indexOf('F');
        int numberOfRemainingTurns = 3;
        selectedPiece.setStatus(FROZEN);
        opponentPlayer.setFrozenPiece(true);
        //we keep y+1 and x+1 to maintain the professor strings
        opponentPlayer.setFrozenPieceInformation(String.valueOf(selectedPiece.getyCoordinate()+1)+String.valueOf(selectedPiece.getxCoordinate()+1)+String.valueOf(numberOfRemainingTurns));
        playerPlaying.setUnusedSpells(playerPlaying.getUnusedSpells().substring(0,indexOfFreeze)+'0'+playerPlaying.getUnusedSpells().substring(indexOfFreeze+1,playerPlaying.getUnusedSpells().length()));
    }


    /**
     * This method updates the Piece positional attributes and the fantasy_board configuration as a result of a move.
     * @param selectedPiece the piece that performs the move
     */
    public void updateBoard(int newXPosition, int newYPosition, Piece selectedPiece) {
        // update the fantasy_board
        this.currentConfiguration[selectedPiece.getxCoordinate()][selectedPiece.getyCoordinate()] = '0';
        //updating the symbols
        this.currentConfiguration[newXPosition][newYPosition] = selectedPiece.getPieceSymbol();

        // update the piece
        selectedPiece.setxCoordinate(newXPosition);
        selectedPiece.setyCoordinate(newYPosition);
    }


    /**
     * This method executes the combat between two pieces, which is started once one piece occupied a cell occupied by an opponent piece.
     * They decrease each other's vitality until one or both of them fall dead. If a piece is frozen, it automatically dies without
     * inflicting any damage to the opponent. If both are frozen, they both die.
     * @param selectedPiece the piece that has performed the move
     * @param foe the attacked piece
     */
    public void engageInBattle(Piece selectedPiece, Piece foe) {
        if(selectedPiece.getStatus()== FROZEN || foe.getStatus()== FROZEN){
            if(selectedPiece.getStatus()== FROZEN){
                selectedPiece.setVitality(0);
                if(isUpperCase(selectedPiece.getPieceSymbol())){
                    this.getPlayers()[0].setFrozenPiece(false);
                    this.getPlayers()[0].setFrozenPieceInformation("000");
                }else{
                    this.getPlayers()[1].setFrozenPiece(false);
                    this.getPlayers()[1].setFrozenPieceInformation("000");
                }
            }
            if(foe.getStatus()== FROZEN){
                foe.setVitality(0);
                if(isUpperCase(foe.getPieceSymbol())){
                    this.getPlayers()[0].setFrozenPiece(false);
                    this.getPlayers()[0].setFrozenPieceInformation("000");
                }else{
                    this.getPlayers()[1].setFrozenPiece(false);
                    this.getPlayers()[1].setFrozenPieceInformation("000");
                }
            }
        }else {
            // decrement one piece vitality until one of the two get vitality below or equals 0
            do {
                foe.setVitality(foe.getVitality() - selectedPiece.getAttackStrength().getValue());
                selectedPiece.setVitality(selectedPiece.getVitality() - foe.getAttackStrength().getValue());
            } while (selectedPiece.getVitality() > 0 && foe.getVitality() > 0);
        }

        int foeCurrentVitality = foe.getVitality();
        // update the fantasy_board and remove dead piece from the corresponding list
        // if both pieces die
        if (selectedPiece.getVitality() <= 0 && foe.getVitality() <= 0) {
            this.currentConfiguration[selectedPiece.getxCoordinate()][selectedPiece.getyCoordinate()] = '0';
            this.currentConfiguration[foe.getxCoordinate()][foe.getyCoordinate()] = '0';

            pieces[turn].remove(getPieceIndexAtTurn(turn,selectedPiece.getyCoordinate(),selectedPiece.getxCoordinate()));
            pieces[(turn + 1) % NUMBER_OF_PLAYERS].remove(getPieceIndexAtTurn((turn + 1) % NUMBER_OF_PLAYERS,foe.getyCoordinate(),foe.getxCoordinate()));
            numberOfDeadPieces += 2;
        }
        else if (selectedPiece.getVitality() <= 0) {
            if(!(selectedPiece.getxCoordinate()==foe.getxCoordinate() && selectedPiece.getyCoordinate()==foe.getyCoordinate())) {
                this.currentConfiguration[selectedPiece.getxCoordinate()][selectedPiece.getyCoordinate()] = '0';
            }
            // assign some points to opponent player
            scores[(turn + 1) % NUMBER_OF_PLAYERS] += foeCurrentVitality + (1 / selectedPiece.getAttackStrength().getValue()) * MAX_STRENGTH;
            pieces[turn].remove(getPieceIndexAtTurn(turn,selectedPiece.getyCoordinate(),selectedPiece.getxCoordinate()));
            numberOfDeadPieces++;
        }
        else if (foe.getVitality() <= 0) {
            if(!(selectedPiece.getxCoordinate()==foe.getxCoordinate() && selectedPiece.getyCoordinate()==foe.getyCoordinate())) {
                updateBoard(foe.getxCoordinate(), foe.getyCoordinate(), selectedPiece);
            }
            else {
                this.currentConfiguration[selectedPiece.getxCoordinate()][selectedPiece.getyCoordinate()] = selectedPiece.getPieceSymbol();
            }
            // assign some points to playing player
            scores[turn] += foeCurrentVitality + (1 / selectedPiece.getAttackStrength().getValue()) * MAX_STRENGTH;
            pieces[(turn + 1) % NUMBER_OF_PLAYERS].remove(getPieceIndexAtTurn((turn + 1) % NUMBER_OF_PLAYERS,foe.getyCoordinate(),foe.getxCoordinate()));
            numberOfDeadPieces++;
        }
    }


    /**
     * This method checks the end of the game.A player P wins when:
     *   – P’s pieces occupy three special cells, or
     *   – P’s opponent’s pieces are all either killed or frozen and P has at least one non-killed and non-frozen piece.
     * If, when it’s P’s turn, P cannot move (all of P’s pieces are either killed or frozen) and P’s opponent hasn’t won, then the
     * game ends in a draw.
     * @return an empty message if the game hasn't finished, or a non-empty string, of the following format:
     * -    "BLACK" if black wins;
     * -    "WHITE" if white wins;
     * -    "DRAW" if it's a draw.
     */
    public String checkEndOfGame() {
        /* if a frozen piece has reached its last turn of freezing, unfreeze now before performing the win checks; otherwise, just decrease
        its number of turns in frozen state
        */
        int remainingFrozenTurns;
        if(this.players[turn].hasFrozenPiece()){
            remainingFrozenTurns = Integer.valueOf(this.players[turn].getFrozenPieceInformation().substring(2,3));
            if(remainingFrozenTurns == 1){
                this.players[turn].setFrozenPiece(false);
                getPieceAtTurn(turn,Integer.valueOf(this.players[turn].getFrozenPieceInformation().substring(0,1))-1,Integer.valueOf(this.players[turn].getFrozenPieceInformation().substring(1,2))-1).setStatus(Status.ACTIVE);
                this.players[turn].setFrozenPieceInformation("000");
            }else{
                remainingFrozenTurns--;
                this.players[turn].setFrozenPieceInformation(this.players[turn].getFrozenPieceInformation().substring(0,2)+String.valueOf(remainingFrozenTurns));
            }
        }

        // 1. check if playing player has no pieces or one frozen piece
        if (pieces[turn].size() == 0 || (pieces[turn].size() == 1 && players[turn].hasFrozenPiece())) {
            // if also the other player has no pieces or one frozen piece -> draw
            if (pieces[(turn + 1) % NUMBER_OF_PLAYERS].size() == 0 || (pieces[(turn + 1) % NUMBER_OF_PLAYERS].size() == 1 && players[(turn + 1) % NUMBER_OF_PLAYERS].hasFrozenPiece())) {
                gameOver = true;
                finalMessage = "DRAW";
                // set the winner name
                winner = "DRAW";
                return finalMessage;
            }
            // otherwise he loses
            else {
                gameOver = true;
                // assign 10 points to opponent
                scores[(turn + 1) % NUMBER_OF_PLAYERS] += 50;
                finalMessage = players[(turn + 1) % NUMBER_OF_PLAYERS].getColor().name();
                // set the winner player
                winner = players[(turn + 1) % NUMBER_OF_PLAYERS].getColor().toString();
                return finalMessage;
            }
        }
        // 2. if playing player has at least one not frozen piece
        else {
            // if this player has occupied at least three special cells -> win
            if (areSpecialCellsOccupied(turn) >= 3) {
                gameOver = true;
                // assign 10 points to playing player + 5 points because it occupied 3 special cells
                scores[turn] += 15;
                finalMessage = players[turn].getColor().name();
                // set the winner player
                winner = players[turn].getColor().toString();
                // set occupied three special cells to true
                occupiedThreeSpecialCells = true;
                return finalMessage;
            }
            // otherwise, check if the other player has no pieces or one frozen piece -> win
            else {
                if (pieces[(turn + 1) % NUMBER_OF_PLAYERS].size() == 0 || (pieces[(turn + 1) % NUMBER_OF_PLAYERS].size() == 1 && players[(turn + 1) % NUMBER_OF_PLAYERS].hasFrozenPiece())) {
                    gameOver = true;
                    // assign 10 points to playing player
                    scores[turn] += 50;
                    finalMessage = players[turn].getColor().name();
                    // set the winner player
                    winner = players[turn].getColor().toString();
                    return finalMessage;
                }
                else {
                    // if the opponent has occupied the three cells -> lose
                    if (areSpecialCellsOccupied((turn + 1) % NUMBER_OF_PLAYERS) >= 3) {
                        gameOver = true;
                        // assign 10 points to opponent + 5 points because it occupied 3 special cells
                        scores[(turn + 1) % NUMBER_OF_PLAYERS] += 15;
                        finalMessage = players[(turn + 1) % NUMBER_OF_PLAYERS].getColor().name();
                        // set the winner player
                        winner = players[(turn + 1) % NUMBER_OF_PLAYERS].getColor().toString();
                        // set occupied three special cells to true
                        occupiedThreeSpecialCells = true;
                        return finalMessage;
                    }
                }
            }
        }

        return finalMessage;
    }


    /**
     * Choose the next turn.
     */
    public void repriseTurn() {
        if (gameOver) {
            // assign classic_score to playing player equals to the sum of player's pieces' vitality still alive
            for (Piece piece: pieces[turn]) {
                scores[turn] += piece.getVitality();
                // count number of pieces from the list of this player
                numberOfPiecesLeft++;
            }
            // assign classic_score to opponent player equals to the sum of player's pieces' vitality still alive
            for (Piece piece: pieces[(turn + 1) % NUMBER_OF_PLAYERS]) {
                scores[(turn + 1) % NUMBER_OF_PLAYERS] += piece.getVitality();
                // count number of pieces from the list of this player
                numberOfPiecesLeft++;
            }

            // finally, assign total classic_score to each player
            players[turn].setScore(scores[turn]);
            players[(turn + 1) % NUMBER_OF_PLAYERS].setScore(scores[(turn + 1) % NUMBER_OF_PLAYERS]);
        }

        turn = (turn + 1) % NUMBER_OF_PLAYERS;
    }


    /**
     * This method returns the string representing the game status as a result of the played turns.
     * @return string of the format:
     *          – either a 67-character string; if during the sequence of turns, black won, the string "BLACK" is appended;
     *            if white won, string "WHITE" is appended; if the game ended in a draw, string "DRAW" is appended
     *          – or a string of the form "ERROR: <explanation>" indicating that something went wrong.
     */
    @Override
    public String toString() {
        // if an invalid action has been performed return only a string containing the error
        if (finalMessage.startsWith("ERROR")) {
            return finalMessage;
        }
        else {
            String stateOfTheGame = "";
            // take just the first letter of player's color name
            stateOfTheGame += players[turn].getColor().name().charAt(0);

            // fantasy_board
            for (int i = 0; i < BOARD_SIDE_SIZE; i++) {
                for (int j = 0; j < BOARD_SIDE_SIZE; j++) {
                    stateOfTheGame += currentConfiguration[i][j];
                }
            }

            // vitalities
            for (int i = 0; i < BOARD_SIDE_SIZE; i++) {
                for (int j = 0; j < BOARD_SIDE_SIZE; j++) {
                    // if the white player is playing
                    if (players[turn].getColor() == WHITE) {
                        // remember: white player is associated with upper case characters
                        if (currentConfiguration[j][i] != '0' && Character.isUpperCase(currentConfiguration[j][i])) {
                            // j is the row, i is the column, because scanning by column
                            stateOfTheGame += getPieceAtTurn(turn, i, j).getVitality();
                        }
                        // in this case the character is lower case, then scan the list of the non-playing player
                        else if (currentConfiguration[j][i] != '0' && isLowerCase(currentConfiguration[j][i])) {
                            stateOfTheGame += getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, i, j).getVitality();
                        }
                    }
                    // in this case it's the black player's turn
                    else {
                        if (currentConfiguration[j][i] != '0' && isLowerCase(currentConfiguration[j][i])) {
                            stateOfTheGame += getPieceAtTurn(turn, i, j).getVitality();
                        }
                        else if (currentConfiguration[j][i] != '0' && Character.isUpperCase(currentConfiguration[j][i])) {
                            stateOfTheGame += getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, i, j).getVitality();
                        }
                    }
                }
            }
            // pad the string with zeros for dead pieces
            for (int i = 0; i < numberOfDeadPieces; i++) {
                stateOfTheGame += '0';
            }

            // frozen pieces: first white, then black
            if (players[turn].getColor() == WHITE) {
                stateOfTheGame += players[turn].getFrozenPieceInformation();
                stateOfTheGame += players[(turn + 1) % NUMBER_OF_PLAYERS].getFrozenPieceInformation();
            } else {
                stateOfTheGame += players[(turn + 1) % NUMBER_OF_PLAYERS].getFrozenPieceInformation();
                stateOfTheGame += players[turn].getFrozenPieceInformation();
            }

            // unused spells: first white, then black
            if (players[turn].getColor() == WHITE) {
                stateOfTheGame += players[turn].getUnusedSpells();
                stateOfTheGame += players[(turn + 1) % NUMBER_OF_PLAYERS].getUnusedSpells();
            } else {
                stateOfTheGame += players[(turn + 1) % NUMBER_OF_PLAYERS].getUnusedSpells();
                stateOfTheGame += players[turn].getUnusedSpells();
            }

            // append name of the winner, draw or error
            stateOfTheGame += finalMessage;

            return stateOfTheGame;
        }
    }


    /**
     * This method is used when we are dealing with some custom configuration so we can start with
     * a game in which have been already committed some actions.
     * @param vitalities is the string that contains the vitalities it has to be of 16 chars. The order of the characters corresponds
     * to the pieces read vertically from top to bottom, one column at a time from left to right.
     * @return a string containing an error message if the vitality value assigned to apiece exceeds its maximum allowed.
     */
    public String setVitalities(String vitalities) {
        int counter = 0;
        for (int i = 0; i < BOARD_SIDE_SIZE; i++) {
            for (int j = 0; j < BOARD_SIDE_SIZE; j++) {
                if (players[turn].getColor() == WHITE) {
                    // remember: white player is associated with upper case characters
                    if (currentConfiguration[j][i] != '0' && Character.isUpperCase(currentConfiguration[j][i])) {
                        // j is the row, i is the column, because scanning by column
                        if (getPieceAtTurn(turn, i, j).getVitality() < Character.getNumericValue(vitalities.charAt(counter))) {
                            return "ERROR: you tried to initialize a piece with a vitality exceeding its maximum allowed.";
                        }
                        getPieceAtTurn(turn, i, j).setVitality(Character.getNumericValue(vitalities.charAt(counter)));
                        counter++;
                    }
                    // in this case the character is lower case, then scan the list of the non-playing player
                    else if (currentConfiguration[j][i] != '0' && isLowerCase(currentConfiguration[j][i])) {
                        if (getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, i, j).getVitality() < Character.getNumericValue(vitalities.charAt(counter))) {
                            return "ERROR: you tried to initialize a piece with a vitality exceeding its maximum allowed.";
                        }
                        getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, i, j).setVitality(Character.getNumericValue(vitalities.charAt(counter)));
                        counter++;
                    }
                }
                // in this case it's the black player's turn
                else {
                    if (currentConfiguration[j][i] != '0' && isLowerCase(currentConfiguration[j][i])) {
                        if (getPieceAtTurn(turn, i, j).getVitality() < Character.getNumericValue(vitalities.charAt(counter))) {
                            return "ERROR: you tried to initialize a piece with a vitality exceeding its maximum allowed.";
                        }
                        getPieceAtTurn(turn, i, j).setVitality(Character.getNumericValue(vitalities.charAt(counter)));
                        counter++;
                    }
                    else if (currentConfiguration[j][i] != '0' && Character.isUpperCase(currentConfiguration[j][i])) {
                        if (getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, i, j).getVitality() < Character.getNumericValue(vitalities.charAt(counter))) {
                            return "ERROR: you tried to initialize a piece with a vitality exceeding its maximum allowed.";
                        }
                        getPieceAtTurn((turn + 1) % NUMBER_OF_PLAYERS, i, j).setVitality(Character.getNumericValue(vitalities.charAt(counter)));
                        counter++;
                    }
                }
            }
        }

        return "";
    }


    /**
     * This method is used by the turnTest(String) method to set the frozen pieces in the game.
     * @param turn the current turn
     * @param frozenPieceInformation the string containing the information regarding a frozen piece: the first two characters
     * represent the position of the cell containing the frozen white piece; the next is the number of remaining turns during
     * which the piece will be frozen.
     */
    public void setPlayerFrozenPieces(int turn, String frozenPieceInformation) {
        if(frozenPieceInformation.charAt(2) != '0') {
            players[turn].setFrozenPiece(true);
            getPieceAtTurn(turn,Integer.valueOf(frozenPieceInformation.substring(0,1))-1,Integer.valueOf(frozenPieceInformation.substring(1,2))-1).setStatus(Status.FROZEN);
        }else {
            players[turn].setFrozenPiece(false);
        }
        players[turn].setFrozenPieceInformation(frozenPieceInformation);
    }


    /**
     * This method is used by the turnTest(String) method to set the list of unused spells.
     * @param turn the current turn
     * @param unusedSpells the list of unused spells is described by an 8-character string (4 for the white mage, followed by 4 for
     * the black mage), where each character is either the initial of the corresponding spell ("F", "H", "R", or "T", to appear in
     * this order) or a "0" if the spell was already used.
     */
    public void setPlayerUnusedSpells(int turn, String unusedSpells) {
        players[turn].setUnusedSpells(unusedSpells);
    }


    /**
     * This method is used to parse a custom configuration string into a matrix that represents
     * the state of the fantasy_board "in medias res"
     * @param customConfiguration a string with a fantasy_board representation differing from the initial standard one
     */
    public void createCustomConfigurationMatrix(String customConfiguration){
        for (int i = 0; i < BOARD_SIDE_SIZE; i++){
            for(int j = 0; j < BOARD_SIDE_SIZE; j++){
                //the method charAt takes the char in the string at position i+j
                this.currentConfiguration[i][j] = customConfiguration.charAt( (i*BOARD_SIDE_SIZE) + j );
                // this matrix stores the default initial configuration of a game regardless of the state on which the game is
                initialConfiguration[i][j] = STANDARD_GAME_CONFIGURATION.charAt( (i*BOARD_SIDE_SIZE) + j );
            }
        }
    }


    /**
     * This method returns a piece from the list of pieces belonging to the player playing the current turn.
     * @param turn the current turn
     * @param y the column position on the fantasy_board
     * @param x the row position on the fantasy_board
     * @return the playing player's piece at the given position on the fantasy_board
     */
    public Piece getPieceAtTurn(int turn, int y, int x) {
        for (Piece p : pieces[turn]) {
            if (p.getxCoordinate() == x && p.getyCoordinate() == y) {
                return p;
            }
        }
        return null;
    }

    /**
     * This method returns the index a piece from the list of pieces belonging to the player playing the current turn.
     * @param turn the current turn
     * @param y the column position on the fantasy_board
     * @param x the row position on the fantasy_board
     * @return the playing player's piece at the given position on the fantasy_board
     */
    public int getPieceIndexAtTurn(int turn, int y, int x) {
        int index = 0;
        for (Piece p : pieces[turn]) {
            if (p.getxCoordinate() == x && p.getyCoordinate() == y) {
                return index;
            }
            index ++;
        }
        return index;
    }


    /**
     * This method checks if the player of the given turn has occupied at least three cells.
     * @param turn the current turn
     * @return the number of special cells occupied
     */
    public int areSpecialCellsOccupied(int turn) {
        int counter = 0;
        for (int i = 0; i < SPECIAL_CELLS_RECORD.length; i++) {
            for (Piece piece: pieces[turn]) {
                if (piece.getxCoordinate() == SPECIAL_CELLS_RECORD[i][0] && piece.getyCoordinate() == SPECIAL_CELLS_RECORD[i][1]) {
                    counter++;
                    break;
                }
            }
        }
        return counter;
    }


    /**
     * Method used to check if we are trying to involve a check on special cells.
     * Is set as static so we can invoke it from the spell avoiding to copy it in the classes.
     * @param x target of x coordinate
     * @param y target of y coordinate
     * @return true if it is a special cell
     */
    public static boolean isSpecialCell(int x, int y){
         for(int i=0; i<SPECIAL_CELLS_RECORD.length; i++){
            if(SPECIAL_CELLS_RECORD[i][0] == x && SPECIAL_CELLS_RECORD[i][1] == y){
                return true;
            }
         }
        return false;
    }

    /**
     * Used to check if the player has the mage alive so if it can cast a spell.
     * @param playerTurn the current turn
     * @return true if the playing player has a mage, false otherwise.
     */
    public boolean playerHasMage(int playerTurn){
        for (Piece p : pieces[playerTurn]) {
            if (p.getPieceSymbol() == 'M' || p.getPieceSymbol() == 'm') {
                return true;
            }
        }
        return false;
    }


    /**
     * This method sets the finalMessage to the given error message.
     * @param errorString the error message
     * @return the error message
     */
    public String generateError(String errorString) {
        finalMessage = errorString;
        return finalMessage;
    }


    /**
     * This method is used for testing purposes only. It flushes the list of pieces from its objects.
     */
    public void resetPlayers() {
        pieces[turn].clear();
        pieces[(turn + 1) % NUMBER_OF_PLAYERS].clear();
    }



    /**
     * Getters and setters
     */

    public String getWhitePlayerName() {
        String playerName = (players[turn].getColor() == WHITE) ? players[turn].getName() : players[(turn + 1) % NUMBER_OF_PLAYERS].getName();
        return playerName;
    }

    public String getBlackPlayerName() {
        String playerName = (players[turn].getColor() == BLACK) ? players[turn].getName() : players[(turn + 1) % NUMBER_OF_PLAYERS].getName();
        return playerName;
    }

    public int getScoreForPlayerAtIndex(int index) {
        return scores[index];
    }

    public String getFinalMessage() {
        return finalMessage;
    }

    public boolean isGameOver() {
        return gameOver;
    }

    public int getTurn() {
        return turn;
    }

    public void setTurn(int turn) {
        this.turn = turn;
    }

    public char[][] getCurrentConfiguration() {
        return currentConfiguration;
    }

    public List<Piece>[] getPieces() {
        return pieces;
    }

    public void setPieces(List<Piece>[] pieces) {
        this.pieces = pieces;
    }

    public void setNumberOfDeadPieces(int numberOfDeadPieces) {
        this.numberOfDeadPieces = numberOfDeadPieces;
    }

    public Player[] getPlayers() {
        return players;
    }

    public String getDateFormat() {
        return dateFormat;
    }

    public String getWinner() {
        return winner;
    }

    public int getNumberOfPiecesLeft() {
        return numberOfPiecesLeft;
    }

    public int getNumberOfTurns() {
        return numberOfTurns;
    }

    public boolean hasOccupiedThreeSpecialCells() {
        return occupiedThreeSpecialCells;
    }

    public void setCurrentConfiguration(char[][] currentConfiguration) {
        this.currentConfiguration = currentConfiguration;
    }

    public void setPlayerOne(Player playerOne) {
        this.players[0] = playerOne;
    }

    public void setPlayerTwo(Player playerTwo) {
        this.players[1] = playerTwo;
    }

    public int getNumberOfDeadPieces() {
        return numberOfDeadPieces;
    }
}